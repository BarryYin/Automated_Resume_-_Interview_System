# 面试追问逻辑说明

## 当前实现

### 问题流程

```
开始面试
  ↓
提问第1个问题
  ↓
候选人回答
  ↓
提交回答给AI评分
  ↓
显示"感谢您的回答！"
  ↓
【追问判断】70%概率显示追问 ← 当前逻辑
  ↓
等待1.5秒
  ↓
提问第2个问题
  ↓
...循环直到第10个问题
  ↓
结束面试
```

### 追问判断逻辑

**位置**：`frontend/js/interview.js` 第463行

```javascript
// 如果有追问，显示追问
if (this.currentQuestionData?.follow_up && Math.random() > 0.3) {
    setTimeout(() => {
        this.addMessage('ai', `追问：${this.currentQuestionData.follow_up}`);
    }, 1000);
}
```

**当前规则**：
- ✅ 如果问题有 `follow_up` 字段
- ✅ 并且随机数 > 0.3（即70%的概率）
- ✅ 则显示追问

**问题**：
1. ❌ **追问只是显示，不等待回答**
2. ❌ **追问后直接进入下一个问题**
3. ❌ **追问的回答不会被评分**
4. ❌ **随机概率不合理**（应该根据回答质量决定）

## 问题数据结构

每个问题包含：
```javascript
{
    "id": 1,
    "dimension": "Knowledge",
    "question": "请介绍一下您的Python开发经验和技术栈。",
    "follow_up": "您最熟悉哪些Python框架？"  // 追问内容
}
```

## 改进建议

### 方案1：智能追问（推荐）

根据AI评分决定是否追问：

```javascript
// 提交回答并获取评分
const evaluation = await this.submitAnswer(answerData);

// 根据评分决定是否追问
if (this.currentQuestionData?.follow_up) {
    // 如果回答得分较低（<70分），进行追问
    if (evaluation.score < 70) {
        setTimeout(() => {
            this.addMessage('ai', `追问：${this.currentQuestionData.follow_up}`);
            this.isWaitingForResponse = true;  // 等待追问的回答
            this.isFollowUpQuestion = true;    // 标记为追问
        }, 1000);
        return;  // 不立即进入下一个问题
    }
}

// 如果不需要追问，继续下一个问题
this.currentQuestion++;
this.updateProgress();
setTimeout(() => {
    this.askNextQuestion();
}, 1500);
```

**优点**：
- ✅ 根据回答质量智能决定
- ✅ 追问更有针对性
- ✅ 可以获取更多信息

**缺点**：
- ⚠️ 面试时间可能变长
- ⚠️ 需要处理追问的回答

### 方案2：固定追问

每个问题都追问：

```javascript
if (this.currentQuestionData?.follow_up) {
    setTimeout(() => {
        this.addMessage('ai', `追问：${this.currentQuestionData.follow_up}`);
        this.isWaitingForResponse = true;
        this.isFollowUpQuestion = true;
    }, 1000);
    return;
}
```

**优点**：
- ✅ 简单直接
- ✅ 每个维度都有深度考察

**缺点**：
- ⚠️ 面试时间翻倍（20个问题）
- ⚠️ 候选人可能感到疲劳

### 方案3：选择性追问

只对重要维度追问：

```javascript
// 定义需要追问的维度
const followUpDimensions = ['Knowledge', 'Skill', 'Ability'];

if (this.currentQuestionData?.follow_up && 
    followUpDimensions.includes(this.currentQuestionData.dimension)) {
    setTimeout(() => {
        this.addMessage('ai', `追问：${this.currentQuestionData.follow_up}`);
        this.isWaitingForResponse = true;
        this.isFollowUpQuestion = true;
    }, 1000);
    return;
}
```

**优点**：
- ✅ 平衡深度和时间
- ✅ 重点考察核心能力

**缺点**：
- ⚠️ 需要定义哪些维度重要

### 方案4：当前方案（仅展示）

保持现状，追问只是提示，不等待回答：

```javascript
// 显示追问作为提示
if (this.currentQuestionData?.follow_up && Math.random() > 0.3) {
    setTimeout(() => {
        this.addMessage('ai', `追问：${this.currentQuestionData.follow_up}`);
    }, 1000);
}

// 继续下一个问题
this.currentQuestion++;
this.updateProgress();
setTimeout(() => {
    this.askNextQuestion();
}, 1500);
```

**优点**：
- ✅ 面试时间可控（固定10个问题）
- ✅ 实现简单

**缺点**：
- ⚠️ 追问没有实际作用
- ⚠️ 候选人可能困惑（看到追问但不知道要不要回答）

## 推荐实现：智能追问

### 完整代码示例

```javascript
async sendMessage() {
    const chatInput = document.getElementById('chatInput');
    const message = chatInput.value.trim();
    
    if (!message || this.isWaitingForResponse === false) {
        return;
    }
    
    // 添加用户消息
    this.addMessage('user', message);
    chatInput.value = '';
    chatInput.style.height = 'auto';
    
    // 保存回答
    const answerData = {
        question: this.currentQuestion,
        questionText: this.currentQuestionData?.question || '',
        answer: message,
        dimension: this.currentQuestionData?.dimension || 'Knowledge',
        timestamp: new Date().toISOString(),
        isFollowUp: this.isFollowUpQuestion || false  // 标记是否为追问的回答
    };
    
    this.messages.push(answerData);
    this.isWaitingForResponse = false;
    
    // 显示AI正在分析
    this.showTypingIndicator();
    this.addMessage('ai', '正在分析您的回答...');
    
    // 提交回答给LLM评估
    const evaluation = await this.submitAnswer(answerData);
    
    // 如果是追问的回答，直接进入下一个问题
    if (this.isFollowUpQuestion) {
        this.isFollowUpQuestion = false;
        this.currentQuestion++;
        this.updateProgress();
        setTimeout(() => {
            this.askNextQuestion();
        }, 1500);
        return;
    }
    
    // 判断是否需要追问
    if (this.currentQuestionData?.follow_up) {
        // 策略1: 根据评分决定（推荐）
        const needFollowUp = evaluation.score < 70;
        
        // 策略2: 根据回答长度决定
        // const needFollowUp = message.length < 100;
        
        // 策略3: 根据维度决定
        // const importantDimensions = ['Knowledge', 'Skill', 'Ability'];
        // const needFollowUp = importantDimensions.includes(this.currentQuestionData.dimension);
        
        if (needFollowUp) {
            setTimeout(() => {
                this.addMessage('ai', `追问：${this.currentQuestionData.follow_up}`);
                this.isWaitingForResponse = true;
                this.isFollowUpQuestion = true;
            }, 1000);
            return;  // 等待追问的回答，不进入下一个问题
        }
    }
    
    // 继续下一个问题
    this.currentQuestion++;
    this.updateProgress();
    setTimeout(() => {
        this.askNextQuestion();
    }, 1500);
}
```

### 追问判断策略对比

| 策略 | 判断条件 | 优点 | 缺点 | 推荐度 |
|------|---------|------|------|--------|
| 评分低于70分 | `score < 70` | 针对性强，获取更多信息 | 可能延长面试时间 | ⭐⭐⭐⭐⭐ |
| 回答太短 | `answer.length < 100` | 鼓励详细回答 | 可能误判 | ⭐⭐⭐ |
| 重要维度 | `dimension in [...]` | 重点考察核心能力 | 需要定义重要维度 | ⭐⭐⭐⭐ |
| 随机概率 | `Math.random() > 0.3` | 简单 | 不智能 | ⭐⭐ |
| 全部追问 | `true` | 全面深入 | 时间太长 | ⭐⭐ |
| 不追问 | `false` | 时间可控 | 缺少深度 | ⭐ |

## 数据流程

### 当前流程（无实际追问）

```
问题1 → 回答1 → 评分1 → [显示追问但不等待] → 问题2
```

### 改进后流程（智能追问）

```
问题1 → 回答1 → 评分1 → [评分<70?] 
                           ↓ 是
                        追问1 → 回答1.1 → 评分1.1 → 问题2
                           ↓ 否
                        问题2
```

## 实现步骤

### 1. 添加追问状态标记

```javascript
class InterviewSession {
    constructor() {
        // ... 现有代码
        this.isFollowUpQuestion = false;  // 是否为追问
    }
}
```

### 2. 修改submitAnswer返回评分

```javascript
async submitAnswer(answerData) {
    // ... 提交逻辑
    
    const evaluation = await response.json();
    
    // 保存评分
    this.evaluations.push({
        question: answerData.question,
        dimension: answerData.dimension,
        score: evaluation.score,
        feedback: evaluation.feedback
    });
    
    // 返回评分供追问判断使用
    return evaluation;
}
```

### 3. 修改sendMessage实现智能追问

参考上面的完整代码示例。

### 4. 更新进度显示

```javascript
updateProgress() {
    // 只计算主问题，不计算追问
    const mainQuestionNumber = Math.ceil(this.currentQuestion);
    document.getElementById('currentQuestion').textContent = mainQuestionNumber;
    const progressFill = document.getElementById('progressFill');
    const percentage = (mainQuestionNumber / this.totalQuestions) * 100;
    progressFill.style.width = `${percentage}%`;
}
```

## 总结

**当前实现**：
- 追问只是显示，不等待回答
- 使用随机概率（70%）决定是否显示
- 追问没有实际作用

**推荐改进**：
- 根据AI评分智能决定是否追问
- 等待追问的回答并评分
- 追问的回答也计入评估

**实现难度**：⭐⭐⭐（中等）

**收益**：⭐⭐⭐⭐⭐（高）
- 更深入了解候选人
- 更准确的评估
- 更好的面试体验
