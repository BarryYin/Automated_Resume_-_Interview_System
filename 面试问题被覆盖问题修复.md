# 面试问题被覆盖问题修复

## 问题描述

包涵登录后，虽然数据库中有预生成的10个问题，但面试时看到的问题不是预生成的，而是新生成的问题。

## 问题原因

面试页面的逻辑有问题：

```javascript
// 错误的逻辑
if (有预生成的问题) {
    加载预生成的问题
    this.questions = 预生成的问题  // ← 设置了问题
    
    // ❌ 但是又调用了生成API
    调用 /api/interview/generate-questions
    // 这个API会重新生成问题并保存到数据库
    // 覆盖了预生成的问题！
    
    return;
}
```

**问题流程：**
```
1. 查询数据库 → 找到预生成的10个问题
2. 设置 this.questions = 预生成的问题
3. 调用 /api/interview/generate-questions ← 错误！
4. API重新生成新问题
5. 新问题保存到数据库，覆盖了预生成的问题
6. 虽然 this.questions 还是预生成的问题
7. 但下次查询时，数据库中已经是新问题了
```

## 修复方案

修改面试页面逻辑，如果找到预生成的问题，**不要调用生成API**。

### 修改的文件

`frontend/js/interview.js` - `generateInterviewQuestions()` 方法

### 修复前的代码

```javascript
if (questionsData.has_questions && questionsData.questions.length > 0) {
    console.log('使用数据库中保存的面试问题');
    this.questions = questionsData.questions;
    this.totalQuestions = this.questions.length;
    
    // ❌ 错误：又调用了生成API
    const sessionResponse = await fetch('http://localhost:8000/api/interview/generate-questions', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestData)
    });
    
    if (sessionResponse.ok) {
        const sessionData = await sessionResponse.json();
        this.sessionId = sessionData.session_id;
    }
    
    return;
}
```

### 修复后的代码

```javascript
if (questionsData.has_questions && questionsData.questions.length > 0) {
    console.log('✓ 使用数据库中保存的面试问题');
    console.log('问题数量:', questionsData.questions.length);
    console.log('问题策略:', questionsData.strategy);
    
    // ✅ 直接使用预生成的问题
    this.questions = questionsData.questions;
    this.totalQuestions = this.questions.length;
    
    // ✅ 使用已有的session_id（从登录时获取的）
    this.sessionId = session.sessionId;
    
    // ✅ 不调用生成API，直接返回
    return;
}
```

## 修复后的流程

```
1. 候选人登录
   ↓
2. 查询数据库中的预生成问题
   ↓
3. 找到预生成的10个问题
   ↓
4. 直接使用这些问题 ✓
   ↓
5. 不调用生成API ✓
   ↓
6. 预生成的问题不会被覆盖 ✓
   ↓
7. 候选人看到的是管理员预设的问题 ✓
```

## 关键改动

### 1. 移除了生成API调用

```javascript
// 删除了这段代码
const sessionResponse = await fetch('http://localhost:8000/api/interview/generate-questions', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify(requestData)
});
```

### 2. 使用已有的session_id

```javascript
// 修改前：从生成API获取新的session_id
this.sessionId = sessionData.session_id;

// 修改后：使用登录时已经创建的session_id
this.sessionId = session.sessionId;
```

### 3. 添加调试日志

```javascript
console.log('✓ 使用数据库中保存的面试问题');
console.log('问题数量:', questionsData.questions.length);
console.log('问题策略:', questionsData.strategy);
```

## 验证方法

### 方法1: 查看浏览器控制台

1. 打开 `frontend/candidate-login.html`
2. 输入包涵的信息登录
3. 打开浏览器控制台（F12）
4. 应该看到：
   ```
   ✓ 使用数据库中保存的面试问题
   问题数量: 10
   问题策略: 重点考察产品思维...
   ```

### 方法2: 检查问题内容

包涵的预生成问题应该是针对C端产品经理的，例如：
- "请介绍一下您对AIGC领域的理解..."
- "请描述一个您主导的C端产品从0到1的完整过程..."
- 等等

如果看到的是通用问题（如"请简单介绍一下您自己..."），说明还是生成了新问题。

### 方法3: 检查数据库

```bash
sqlite3 backend/recruitment.db << 'EOF'
SELECT candidate_name, 
       LENGTH(questions_json) as json_length,
       updated_at
FROM interview_questions
WHERE candidate_name = '包涵';
EOF
```

如果 `updated_at` 时间是最近的（刚刚面试的时间），说明问题被覆盖了。
如果 `updated_at` 时间是之前的（2025-10-25），说明问题没有被覆盖。

## API说明

### `/api/interview/generate-questions` (POST)

**用途**：生成新的面试问题并保存到数据库

**行为**：
- 调用LLM生成新问题
- 保存到 `interview_session_questions` 表
- **会覆盖** `interview_questions` 表中的预生成问题

**应该在什么时候调用**：
- ✅ 候选人第一次面试，没有预生成问题时
- ❌ 候选人已有预生成问题时（会覆盖预设问题）

### `/api/candidates/{id}/questions` (GET)

**用途**：查询候选人的预生成问题

**行为**：
- 从 `interview_questions` 表查询
- 不会修改数据
- 只读操作

**应该在什么时候调用**：
- ✅ 面试开始前，检查是否有预生成问题
- ✅ 管理员查看候选人的问题

## 相关功能

### 管理员预生成问题流程

```
1. 管理员在候选人列表点击"面试问题"
   ↓
2. 点击"重新生成问题"或"提出修改意见"
   ↓
3. 调用 /api/candidates/{id}/generate-questions
   ↓
4. 问题保存到 interview_questions 表
   ↓
5. 候选人面试时使用这些问题 ✓
```

### 候选人面试流程

```
1. 候选人登录
   ↓
2. 查询 /api/candidates/{id}/questions
   ↓
3. 如果有预生成问题 → 使用预生成问题 ✓
   如果没有 → 调用生成API创建新问题
   ↓
4. 开始面试
```

## 总结

✅ **修复完成**：面试页面不再覆盖预生成的问题
✅ **逻辑正确**：有预生成问题时直接使用，不调用生成API
✅ **功能完整**：管理员预设的问题会被正确使用

**包涵现在登录后会看到：**
- 管理员预设的10个C端产品经理问题
- 针对AIGC领域的深度问题
- 不会每次都生成新问题

**关键点**：
- 预生成问题 = 管理员精心准备的问题
- 实时生成问题 = 系统自动生成的通用问题
- 应该优先使用预生成问题！
